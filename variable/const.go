package main

import (
	"fmt"
)

/*
* 定数
 */
// パッケージに定義された定数
const X = 1

func constSample() {
	// 関数内でも定義可能
	const (
		Y = 2
		Z = 3
	)
	fmt.Printf("%v %v %v\n", X, Y, Z)

	/*
	* 値の省略
	 */
	// 省略する場合初めに定義された定数の値がそのまま以降の定数に割り当てられる
	// 途中で値を定義した場合は暗黙的に値が切り替わる
	// ※全ての値の省略は不可
	const (
		X1 = 1
		Y1 // 1
		Z1 // 1
		S1 = "text"
		S2 // text
	)
	fmt.Printf("%v %v %v %v %v\n", X1, Y1, Z1, S1, S2)

	/*
	* 定数の型
	 */
	// 型を明示的に指定する場合はF64の様に値の方に型を指定する
	const (
		N         = 1
		I64 int64 = -1
		F64       = float64(1.2)
	)
	fmt.Printf("%T %T %T\n", N, I64, F64)

	/*
	* 整数値の定数
	 */
	// 整数値の定数には原則最大値がない
	// しかし、通常の変数に代入しようとするとコンパイルエラーが発生する
	const M = 99999999999999999999999999999999
	// i := M ← オーバーフローになりエラー
	// また、定数同士の演算はプログラム実行時ではなくコンパイル時に処理される

	/*
	* 浮動小数点の定数
	 */
	// 浮動小数点の定数はfloat64型よりも大きな精度の値を定義することが可能
	// その為、定数間で演算を行えば不動小数点の演算誤差を抑えることができる

	/*
	* iota
	 */
	// Goには列挙型の様な機能はないが定義済み識別子のiotaを定数定義と
	// 組み合わせて使う事でCにおける列挙型に近い振る舞いを実現できる
	const (
		A = iota // A == 0
		B        // B == 1
		C        // C == 2
		D = 17   // D == 17
		E = iota // E == 4
		F        // F == 5
	)
	fmt.Printf("%v %v %v %v %v %v\n", A, B, C, D, E, F)
	// iotaは参照の有無に関わらずconstブロック内で定数が定義される度に1ずつ増分する
	// カウンターのイメージではなく、定数群に付与されたインデックスのイメージ
}
