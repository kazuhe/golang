package main

import (
	"fmt"
)

func arrayTest() {
	/*
	* 配列型
	 */
	a := [5]int{1, 2, 3, 4, 5}
	fmt.Printf("%v\n", a) // → [1 2 3 4 5]

	// [n]で配列の要素を参照する
	fmt.Printf("%v\n", a[2]) // → 3

	// 設定した要素数より初期値が少ない場合は整数であれば「0」となる
	a2 := [5]int{1, 2, 3}
	fmt.Printf("%v\n", a2) // → [1 2 3 4 5]

	// ↓要素数が超過するとエラーになる
	// a3 := [5]int{1, 2, 3, 4, 5, 6}

	// 設定した要素数より初期値が少ない場合は文字列であれば「""」となる
	// 論理値であれば「false」となる
	a4 := [5]string{"array", "a"}
	a5 := [5]bool{true, true}
	fmt.Printf("%v\n", a4) // → [array a   ]
	fmt.Printf("%v\n", a5) // → [true true false false false]

	/*
	* 要素数の省略
	 */
	// 省略した場合は、与えられた初期値が要素数となる
	a6 := [...]int{1, 2, 3}
	fmt.Printf("%v\n", a6) // → [1 2 3]

	/*
	* 要素の代入
	 */
	a6[0] = 10
	fmt.Printf("%v\n", a6) // → [10 2 3]

	/*
	* 配列型の互換性
	 */
	// 要素の型が同じでも要素数が異なる変数動同士の代入はエラーとなる
	// var (
	// 	a7 [3]int
	// 	a8 [5]int
	// )
	// a7 = a8 → 型が異なるとされエラー

	// 要素数が同数の場合は当然代入可能
	a9 := [3]int{1, 2, 3}
	a10 := [3]int{4, 5, 6}

	a10 = a9
	fmt.Printf("a9=%v\n", a9)   // → a9=[1 2 3]
	fmt.Printf("a10=%v\n", a10) // → a10=[1 2 3]
	// 配列型の代入では全ての要素のコピーが発生し、
	// a9をa10に代入してもa9には影響なくメモリ上では別の領域に分かれたまま

	/*
	* 配列の拡張
	 */
	// Goの配列型の拡張や縮小は不可能
	// 可変長配列を扱うにはSliceというデータ構造を使う
}
